theory Complete
     imports Main
begin

text \<open> Let's work with skeletons of binary trees where neither the leaves
(``tip'') nor the nodes contain any information: \<close>

datatype tree = Tp | Nd tree tree

text \<open> Define a function @{term tips} that counts the tips of a tree, and a
function @{term height} that computes the height of a tree. \<close>

primrec tips :: "tree \<Rightarrow> nat"
  where
"tips Tp = 1" |
"tips (Nd l r) = tips l + tips r"

primrec height :: "tree \<Rightarrow> nat"
  where
"height Tp = 0" |
"height (Nd l r) = 1 + max (height l) (height r)"

text \<open> Complete binary trees of a given height are generated as follows: \<close>

primrec cbt :: "nat \<Rightarrow> tree" where
"cbt 0       = Tp" |
"cbt (Suc n) = Nd (cbt n) (cbt n)"

text \<open> We will now focus on these complete binary trees.

Instead of generating complete binary trees, we can also \emph{test} if a
binary tree is complete.  Define a function @{term "iscbt f"} (where @{term f}
is a function on trees) that checks for completeness:  @{term Tp} is complete,
and @{term"Nd l r"} is complete iff @{term l} and @{term r} are complete and
@{prop"f l = f r"}. \<close>

primrec iscbt :: "(tree \<Rightarrow> 'a) \<Rightarrow> tree \<Rightarrow> bool"
  where
"iscbt _ Tp = True" |
"iscbt f (Nd l r) = ((iscbt f l) \<and> (iscbt f r) \<and> ((f l) = (f r)))"

text \<open> We now have 3 functions on trees, namely @{term tips}, @{term height}
and @{term size}.  The latter is defined automatically -- look it up in the
tutorial.  Thus we also have 3 kinds of completeness:  complete wrt.\ @{term
tips}, complete wrt.\ @{term height} and complete wrt.\ @{term size}.  Show
that
\begin{itemize}
\item the 3 notions are the same (e.g.\ @{prop "iscbt tips t = iscbt size t"}),
      and
\item the 3 notions describe exactly the trees generated by @{term cbt}:  the
      result of @{term cbt} is complete (in the sense of @{term iscbt}, wrt.\
      any function on trees), and if a tree is complete in the sense of @{term
      iscbt}, it is the result of @{term cbt} (applied to a suitable number~--
      which one?).
\end{itemize}

Hints:
\begin{itemize}
\item Work out and prove suitable relationships between @{term tips}, @{term
      height} und @{term size}.

\item If you need lemmas dealing only with the basic arithmetic operations
      (@{text"+"}, @{text"*"}, @{text"^"} etc), you may ``prove'' them with the
      command @{text sorry}, if neither @{text arith} nor you can find a proof.
      Not @{text "apply sorry"}, just @{text sorry}.

\item You do not need to show that every notion is equal to every other notion.
      It suffices to show that $A = C$ und $B = C$ -- $A = B$ is a trivial
      consequence.  However, the difficulty of the proof will depend on which
      of the equivalences you prove.

\item There is @{text"\<and>"} and @{text"\<longrightarrow>"}.
\end{itemize} \<close>

lemma tips_size_equiv:"tips t = size t + 1"
  apply (induction t) by auto

value "(1^1)::nat"

lemma tips_tips_height_equiv:"iscbt tips t \<Longrightarrow> tips t = 2^(height t)"
  apply (induction t) by auto

lemma height_tips_height_equiv:"iscbt height t \<Longrightarrow> tips t = 2^(height t)"
  apply (induction t) by auto

lemma size_size_height_equiv:"iscbt height t \<Longrightarrow> size t  = (2^(height t)) - 1"
  apply (induction t)
   apply simp_all
  by (metis Suc_diff_Suc add_is_1 minus_nat.diff_0 mult_2 not_gr0 numeral_2_eq_2
      old.nat.distinct(2) power_not_zero trans_less_add2 zero_less_diff)

lemma "iscbt tips t = iscbt size t"
  apply (induction t)
  by (auto simp add: tips_size_equiv)
  

lemma "iscbt tips t = iscbt height t"
  apply (induction t)
  by (auto simp add: height_tips_height_equiv)

text \<open> Find a function @{term f} such that @{term "iscbt f"} is different from
@{term "iscbt size"}. \<close>

lemma "iscbt (\<lambda> t. size t = 2) \<noteq> iscbt size"
  apply (rule notI)
  apply (drule cong[where x="Nd Tp (Nd Tp Tp)"])
   apply simp
  by simp
  
end
